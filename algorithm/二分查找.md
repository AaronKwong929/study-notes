# 二分查找

具体攻略看[这里](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)

> 以下是对攻略的部分关键点总结，具体的还是要看 ↑

二分查找关键在于利用单调性解决问题

## 把待搜索的区间分为两个部分

左半 和 右半

一定不存在目标元素的区间在下一轮搜索不用考虑到

↑ mid 一定会被分到左/右区间内，产生两种写法

mid 在左区间：[left....mid] [mid+1......right] => left = mid + 1, right = mid

mid 在右区间：[left....mid-1] [mid....right] => left = mid, right = mid - 1

看下面这张图就好理解了

![](https://raw.githubusercontent.com/AaronKwong929/pictures/master/20210701174432.png)

**要认真思考下一轮区间究竟在哪里，考虑下一轮更新是 left 还是 right**

## 写 if 的时候把不容易出错的最容易概括全的部分写进去，另外的部分直接写进 else 就不用考虑了

### 704. 二分查找

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function (nums, target) {
    let left = 0,
        right = nums.length - 1;
    while (left <= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
};
console.log(search([-1, 0, 3, 5, 9, 12], 9));
```

### while 循环条件中的是"<=" 不是 "<" ?

因为初始化右边值为 right = nums.length - 1，最后一个索引值，

-1 的话就是左闭右闭区间，不 -1 是左闭右开区间，出现在不同功能的二分查找中

#### 所以如果循环条件是 "<" 那么 right 就要设置成 right = nums.length

https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/

### while(left <= right) 的终止条件是 left === right + 1
