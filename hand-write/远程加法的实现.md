# 模拟远程加法

> 来自 https://juejin.cn/post/6987529814324281380

```js
// 假设本地机器无法做加减乘除运算，需要通过远程请求让服务端来实现。
// 以加法为例，现有远程API的模拟实现

const addRemote = async (a, b) =>
  new Promise(resolve => {
    setTimeout(() => resolve(a + b), 1000);
  });

// 请实现本地的add方法，调用addRemote，能最优的实现输入数字的加法。
async function add(...inputs) {
  // 你的实现
}

// 请用示例验证运行结果:
add(1, 2).then(result => {
  console.log(result); // 3
});

add(3, 5, 2).then(result => {
  console.log(result); // 10
});
```

## 基础

### 普通

```js
async function add(...inputs) {
  let res = 0;
  if (inputs.length === 0) return 0;
  if (inputs.length === 1) return res[0];
  for (const item of inputs) {
    res += await addRemote(res, item);
  }
  return res;
}
```

### 递归

```js
async function add(...inputs) {
  if (inputs.length === 0) return 0;
  if (inputs.length === 1) return res[0];
  const a = inputs.pop(),
    b = inputs.pop();
  inputs.push(await addRemote(a, b));
  return add(...inputs);
}
```

## 优化

### 用 reduce

1. 对 async/await 的理解

2. 对 reduce 的掌握

reduce 的第二个参数 默认值为 0，但这是个 async function 所以要 Promise.resolve(0)

↑因为初始值是 Promise.resolve(0)，reduce 里的pre可以直接用.then 获取到初始的那个0，addRemote返回的也是promise

```js
async function add(...inputs) {
  return inputs.reduce(
    (pre, cur) => pre.then(res => addRemote(res, cur)),
    Promise.resolve(0)
  );
}
```

### 加缓存

```js
const cache = {};

const addFn = async (a, b) => {
  const key1 = `${a},${b}`,
    key2 = `${b},${a}`;
  const cacheVal = cache[key1] || cache[key2];
  if (cacheVal) return cacheVal;
  const res = await addRemote(a, b);
  cache[key1] = res;
  cache[key2] = res;
  return res;
};

async function add(...inputs) {
  let res = 0;
  if (inputs.length === 0) return 0;
  if (inputs.length === 1) return res[0];
  for (const item of inputs) {
    res += addFn(res, item);
  }
  return res;
}
```
