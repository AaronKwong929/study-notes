# 简述 JS 垃圾回收

## 前置知识

JS 基本类型存放在栈内存中，引用类型存放在堆内存中

栈要维护执行上下文的状态，栈太大的话会影响上下文切换的效率，通常设置较小

堆可以存放很多量大的数据，但是分配和回收内存的时间会长

## 代际假说

1. 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；

2. 不死的对象，会活得更久。

V8 将堆内存分为新生代和老生代两个区域

新生代 - 1-8M 大小 - 副垃圾回收器

老生代 - 更大 - 主垃圾回收器

## 新生代垃圾回收

scavenge 算法，把新生代划分成对象区域和空闲区域，对象区域快写满时，进行垃圾回收

标记垃圾，将存活对象复制到空闲区域（此时完成紧凑排列），然后清空原对象区域，然后将空闲区域和对象区域互换

复制需要时间成本，所以新生代区域会设置得小一点

经过两次新生代垃圾回收的内容会被晋升到老生代区域中（对象晋升）

## 老生代垃圾回收

除了在新生代`对象晋升`过来的内容还有一开始就被分配到老生代的内容

内容占用空间大，存活时间长

采用`标记 - 清除`法，会产生内存碎片 ==> `标记 - 整理`，让存活的对象往一侧移动

## 垃圾回收导致全停顿

js 单线程特性，垃圾回收阻塞 js 运行，导致卡顿

`增量标记`将标记过程分为多个子标记过程，让垃圾回收标记和 js 交替运行直到标记完成，减少卡顿
